#!/usr/bin/env python3
"""Docker CLI plugin to pull updates for all local Docker images."""

import argparse
import sys
from concurrent.futures import ThreadPoolExecutor, as_completed
from dataclasses import dataclass
from enum import Enum

try:
    import cli_helper as cli
except ImportError:
    import os

    sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
    import cli_helper as cli

PLUGIN_METADATA = {
    "SchemaVersion": "0.1.0",
    "Vendor": "delfianto",
    "Version": "1.0.0",
    "ShortDescription": "Pull updates for all local Docker images",
}


class PullStatus(Enum):
    """Status codes for image pull operations."""

    UPDATED = 0
    FAILED = 1
    UNCHANGED = 2


@dataclass
class PullResult:
    """Result of a single image pull operation."""

    image: str
    status: PullStatus
    output: str = ""


def get_all_images():
    """Get all Docker images with repository and tag."""
    result = cli.run_docker_command(
        ["image", "ls", "--format", "{{.Repository}}:{{.Tag}}"],
        check=True,
    )

    images = []
    for line in result.stdout.strip().split("\n"):
        if line and not line.endswith(":"):
            images.append(line)

    return sorted(images)


def pull_image(
    image: str, index: int, total: int, show_progress: bool = True
) -> PullResult:
    """
    Pull a single Docker image.

    Args:
        image: Image name with tag
        index: Current image index
        total: Total number of images
        show_progress: Whether to show progress messages

    Returns:
        PullResult with status and output
    """
    if show_progress:
        print(
            f"{cli.CYAN}[{index}/{total}]{cli.NC} Pulling {cli.GREEN}{image}{cli.NC}..."
        )

    try:
        result = cli.run_docker_command(
            ["pull", image],
            check=False,
            timeout=300,  # 5 minute timeout per image
        )

        output = result.stdout + result.stderr

        if result.returncode == 0:
            if (
                "Image is up to date" in output
                or "Status: Image is up to date" in output
            ):
                if show_progress:
                    print(f"{cli.BLUE}  ✓ Already up to date{cli.NC}")
                return PullResult(image, PullStatus.UNCHANGED, output)
            else:
                if show_progress:
                    print(f"{cli.GREEN}  ✓ Updated successfully{cli.NC}")
                return PullResult(image, PullStatus.UPDATED, output)
        else:
            if show_progress:
                print(f"{cli.RED}  ✗ Failed to pull{cli.NC}")
                # Show first 5 lines of error
                error_lines = output.split("\n")[:5]
                for line in error_lines:
                    if line.strip():
                        print(f"    {line}")
            return PullResult(image, PullStatus.FAILED, output)

    except Exception as e:
        if show_progress:
            print(f"{cli.RED}  ✗ Error: {e}{cli.NC}")
        return PullResult(image, PullStatus.FAILED, str(e))


def pull_images_parallel(images: list, max_workers: int = 4) -> list[PullResult]:
    """Pull images in parallel using ThreadPoolExecutor."""
    cli.print_warning(f"Pulling images in parallel (max {max_workers} concurrent)...\n")

    results = []
    total = len(images)

    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        # Submit all tasks
        future_to_image = {
            executor.submit(pull_image, img, idx + 1, total, False): (img, idx + 1)
            for idx, img in enumerate(images)
        }

        # Process completed tasks
        for future in as_completed(future_to_image):
            img, idx = future_to_image[future]
            try:
                result = future.result()
                results.append(result)

                # Show completion status
                status_symbol = "✓" if result.status != PullStatus.FAILED else "✗"
                status_color = (
                    cli.GREEN
                    if result.status == PullStatus.UPDATED
                    else (
                        cli.BLUE if result.status == PullStatus.UNCHANGED else cli.RED
                    )
                )

                print(f"{status_color}{status_symbol}{cli.NC} [{idx}/{total}] {img}")

            except Exception as e:
                print(f"{cli.RED}✗{cli.NC} [{idx}/{total}] {img} - Error: {e}")
                results.append(PullResult(img, PullStatus.FAILED, str(e)))

    return results


def pull_images_sequential(images: list) -> list[PullResult]:
    """Pull images sequentially."""
    results = []
    total = len(images)

    for idx, image in enumerate(images, 1):
        result = pull_image(image, idx, total, show_progress=True)
        results.append(result)
        print()  # Empty line between pulls

    return results


def print_summary(results: list[PullResult], total: int):
    """Print summary of pull operations."""
    updated = sum(1 for r in results if r.status == PullStatus.UPDATED)
    unchanged = sum(1 for r in results if r.status == PullStatus.UNCHANGED)
    failed = sum(1 for r in results if r.status == PullStatus.FAILED)

    print()
    print(f"{cli.CYAN}{'=' * 40}{cli.NC}")
    cli.print_info("Summary:")
    print(f"  Total images: {cli.BLUE}{total}{cli.NC}")
    print(f"  {cli.GREEN}Updated: {updated}{cli.NC}")
    print(f"  {cli.BLUE}Unchanged: {unchanged}{cli.NC}")
    if failed > 0:
        print(f"  {cli.RED}Failed: {failed}{cli.NC}")
    print(f"{cli.CYAN}{'=' * 40}{cli.NC}")


def main():
    """Main function."""
    # Handle plugin metadata
    cli.handle_metadata(PLUGIN_METADATA)

    # Parse arguments
    parser = argparse.ArgumentParser(
        description="Pull updates for all local Docker images",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    parser.add_argument(
        "--dry-run",
        "-n",
        action="store_true",
        help="Show what would be pulled without actually pulling",
    )
    parser.add_argument(
        "--parallel",
        "-p",
        action="store_true",
        help="Pull images in parallel (4 concurrent pulls)",
    )
    parser.add_argument(
        "--filter",
        "-f",
        type=str,
        default="",
        help="Filter images by name (grep-style substring match)",
    )
    parser.add_argument(
        "--workers",
        "-w",
        type=int,
        default=4,
        help="Number of parallel workers (default: 4)",
    )

    # Parse arguments using cli handler
    args = cli.parse_plugin_args(parser, ["imu", "docker-imu"])

    try:
        # Get all images
        images = get_all_images()

        # Apply filter if specified
        if args.filter:
            images = [img for img in images if args.filter in img]

        total = len(images)

        if total == 0:
            cli.print_warning("No images found to pull")
            return 0

        # Print header
        print(f"{cli.CYAN}╔{'=' * 38}╗{cli.NC}")
        print(f"{cli.CYAN}║  Docker Image Update Tool            ║{cli.NC}")
        print(f"{cli.CYAN}╚{'=' * 38}╝{cli.NC}")
        print()
        print(f"{cli.BLUE}Found {total} image(s) to update{cli.NC}")
        print()

        # Dry run mode
        if args.dry_run:
            cli.print_warning("DRY RUN MODE - No images will be pulled\n")
            for image in images:
                print(f"  {cli.CYAN}→{cli.NC} Would pull: {cli.GREEN}{image}{cli.NC}")
            print()
            cli.print_warning("Run without --dry-run to actually pull images")
            return 0

        # Pull images
        if args.parallel:
            results = pull_images_parallel(images, max_workers=args.workers)
        else:
            results = pull_images_sequential(images)

        # Print summary
        print_summary(results, total)

        # Exit with error code if any pulls failed
        failed_count = sum(1 for r in results if r.status == PullStatus.FAILED)
        return 1 if failed_count > 0 else 0

    except KeyboardInterrupt:
        cli.print_warning("\nInterrupted")
        return 130
    except Exception as e:
        cli.print_error(f"Error: {e}")
        return 1


if __name__ == "__main__":
    sys.exit(main())
