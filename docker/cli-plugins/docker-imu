#!/usr/bin/env python3
"""Docker CLI plugin to pull updates for all local Docker images."""

import argparse
import json
import subprocess
import sys
from concurrent.futures import ThreadPoolExecutor, as_completed
from dataclasses import dataclass
from enum import Enum

# ANSI color codes
RED = "\033[0;31m"
GREEN = "\033[0;32m"
YELLOW = "\033[1;33m"
BLUE = "\033[0;34m"
CYAN = "\033[1;36m"
NC = "\033[0m"  # No Color


class PullStatus(Enum):
    """Status codes for image pull operations."""

    UPDATED = 0
    FAILED = 1
    UNCHANGED = 2


@dataclass
class PullResult:
    """Result of a single image pull operation."""

    image: str
    status: PullStatus
    output: str = ""


def handle_metadata():
    """Handle Docker CLI plugin metadata requests."""

    if "docker-cli-plugin-metadata" in sys.argv:
        metadata = {
            "SchemaVersion": "0.1.0",
            "Vendor": "Custom",
            "Version": "1.0.0",
            "ShortDescription": "Pull updates for all local Docker images",
        }
        print(json.dumps(metadata))
        sys.exit(0)


def get_all_images():
    """Get all Docker images with repository and tag."""
    result = subprocess.run(
        ["docker", "image", "ls", "--format", "{{.Repository}}:{{.Tag}}"],
        capture_output=True,
        text=True,
        check=True,
    )

    images = []
    for line in result.stdout.strip().split("\n"):
        if line and not line.endswith(":<none>"):
            images.append(line)

    return sorted(images)


def pull_image(
    image: str, index: int, total: int, show_progress: bool = True
) -> PullResult:
    """
    Pull a single Docker image.

    Args:
        image: Image name with tag
        index: Current image index
        total: Total number of images
        show_progress: Whether to show progress messages

    Returns:
        PullResult with status and output
    """
    if show_progress:
        print(f"{CYAN}[{index}/{total}]{NC} Pulling {GREEN}{image}{NC}...")

    try:
        result = subprocess.run(
            ["docker", "pull", image],
            capture_output=True,
            text=True,
            timeout=300,  # 5 minute timeout per image
        )

        output = result.stdout + result.stderr

        if result.returncode == 0:
            if (
                "Image is up to date" in output
                or "Status: Image is up to date" in output
            ):
                if show_progress:
                    print(f"{BLUE} ✓ Already up to date{NC}")
                return PullResult(image, PullStatus.UNCHANGED, output)
            else:
                if show_progress:
                    print(f"{GREEN} ✓ Updated successfully{NC}")
                return PullResult(image, PullStatus.UPDATED, output)
        else:
            if show_progress:
                print(f"{RED} ✗ Failed to pull{NC}")
                # Show first 5 lines of error
                error_lines = output.split("\n")[:5]
                for line in error_lines:
                    if line.strip():
                        print(f"  {line}")
            return PullResult(image, PullStatus.FAILED, output)

    except subprocess.TimeoutExpired:
        if show_progress:
            print(f"{RED} ✗ Timeout pulling image{NC}")
        return PullResult(image, PullStatus.FAILED, "Timeout")
    except Exception as e:
        if show_progress:
            print(f"{RED} ✗ Error: {e}{NC}")
        return PullResult(image, PullStatus.FAILED, str(e))


def pull_images_parallel(images: list, max_workers: int = 4) -> list[PullResult]:
    """Pull images in parallel using ThreadPoolExecutor."""
    print(f"{YELLOW}Pulling images in parallel (max {max_workers} concurrent)...{NC}\n")

    results = []
    total = len(images)

    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        # Submit all tasks
        future_to_image = {
            executor.submit(pull_image, img, idx + 1, total, False): (img, idx + 1)
            for idx, img in enumerate(images)
        }

        # Process completed tasks
        for future in as_completed(future_to_image):
            img, idx = future_to_image[future]
            try:
                result = future.result()
                results.append(result)

                # Show completion status
                status_symbol = "✓" if result.status != PullStatus.FAILED else "✗"
                status_color = (
                    GREEN
                    if result.status == PullStatus.UPDATED
                    else (BLUE if result.status == PullStatus.UNCHANGED else RED)
                )
                print(f"{status_color}{status_symbol}{NC} [{idx}/{total}] {img}")

            except Exception as e:
                print(f"{RED}✗{NC} [{idx}/{total}] {img} - Error: {e}")
                results.append(PullResult(img, PullStatus.FAILED, str(e)))

    return results


def pull_images_sequential(images: list) -> list[PullResult]:
    """Pull images sequentially."""
    results = []
    total = len(images)

    for idx, image in enumerate(images, 1):
        result = pull_image(image, idx, total, show_progress=True)
        results.append(result)
        print()  # Empty line between pulls

    return results


def print_summary(results: list[PullResult], total: int):
    """Print summary of pull operations."""
    updated = sum(1 for r in results if r.status == PullStatus.UPDATED)
    unchanged = sum(1 for r in results if r.status == PullStatus.UNCHANGED)
    failed = sum(1 for r in results if r.status == PullStatus.FAILED)

    print()
    print(f"{CYAN}{'=' * 40}{NC}")
    print(f"{CYAN}Summary:{NC}")
    print(f"  Total images: {BLUE}{total}{NC}")
    print(f"  {GREEN}Updated: {updated}{NC}")
    print(f"  {BLUE}Unchanged: {unchanged}{NC}")
    if failed > 0:
        print(f"  {RED}Failed: {failed}{NC}")
    print(f"{CYAN}{'=' * 40}{NC}")


def main():
    """Main function."""
    handle_metadata()

    # Parse arguments
    parser = argparse.ArgumentParser(
        description="Pull updates for all local Docker images",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        "--dry-run",
        "-n",
        action="store_true",
        help="Show what would be pulled without actually pulling",
    )
    parser.add_argument(
        "--parallel",
        "-p",
        action="store_true",
        help="Pull images in parallel (4 concurrent pulls)",
    )
    parser.add_argument(
        "--filter",
        "-f",
        type=str,
        default="",
        help="Filter images by name (grep-style substring match)",
    )
    parser.add_argument(
        "--workers",
        "-w",
        type=int,
        default=4,
        help="Number of parallel workers (default: 4)",
    )

    # Skip plugin name if passed as first argument
    args_to_parse = sys.argv[1:]
    if args_to_parse and args_to_parse[0] in ["imu", "docker-imu"]:
        args_to_parse = args_to_parse[1:]

    args = parser.parse_args(args_to_parse)

    try:
        # Get all images
        images = get_all_images()

        # Apply filter if specified
        if args.filter:
            images = [img for img in images if args.filter in img]

        total = len(images)

        if total == 0:
            print(f"{YELLOW}No images found to pull{NC}")
            return 0

        # Print header
        print(f"{CYAN}╔{'=' * 38}╗{NC}")
        print(f"{CYAN}║ Docker Image Update Tool             ║{NC}")
        print(f"{CYAN}╚{'=' * 38}╝{NC}")
        print()
        print(f"{BLUE}Found {total} image(s) to update{NC}")
        print()

        # Dry run mode
        if args.dry_run:
            print(f"{YELLOW}DRY RUN MODE - No images will be pulled{NC}\n")
            for image in images:
                print(f"  {CYAN}→{NC} Would pull: {GREEN}{image}{NC}")
            print()
            print(f"{YELLOW}Run without --dry-run to actually pull images{NC}")
            return 0

        # Pull images
        if args.parallel:
            results = pull_images_parallel(images, max_workers=args.workers)
        else:
            results = pull_images_sequential(images)

        # Print summary
        print_summary(results, total)

        # Exit with error code if any pulls failed
        failed_count = sum(1 for r in results if r.status == PullStatus.FAILED)
        return 1 if failed_count > 0 else 0

    except subprocess.CalledProcessError as e:
        print(f"{RED}Error running docker command: {e}{NC}", file=sys.stderr)
        return 1
    except KeyboardInterrupt:
        print(f"\n{YELLOW}Interrupted{NC}", file=sys.stderr)
        return 130


if __name__ == "__main__":
    sys.exit(main())
