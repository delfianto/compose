#!/usr/bin/env python3
"""
Docker CLI plugin to bootstrap networks from config file
"""

import argparse
import json
import subprocess
import sys
from pathlib import Path

try:
    import tomllib  # Python 3.11+
except ImportError:
    try:
        import tomli as tomllib  # fallback for older Python
    except ImportError:
        print("Error: Please install tomli: pip install tomli", file=sys.stderr)
        sys.exit(1)

# Required for Docker CLI plugins
PLUGIN_METADATA = {
    "SchemaVersion": "0.1.0",
    "Vendor": "homelab",
    "Version": "1.0.0",
    "ShortDescription": "Bootstrap Docker networks from config file",
}


def run_docker_command(args):
    """Execute docker command and return result"""
    try:
        result = subprocess.run(
            ["docker"] + args, capture_output=True, text=True, check=False
        )
        return result
    except Exception as e:
        print(f"Error executing docker command: {e}", file=sys.stderr)
        return None


def create_network(name, config, dry_run=False):
    """Create a single Docker network"""
    cmd = ["network", "create"]

    # Driver
    cmd.extend(["--driver", config.get("driver", "bridge")])

    # Internal flag
    if config.get("internal", False):
        cmd.append("--internal")

    # Subnet and gateway
    if "subnet" in config:
        cmd.extend(["--subnet", config["subnet"]])
    if "gateway" in config:
        cmd.extend(["--gateway", config["gateway"]])

    # Labels
    labels = config.get("labels", {})
    for key, value in labels.items():
        cmd.extend(["--label", f"{key}={value}"])

    # Network name
    cmd.append(name)

    # Show command in dry-run mode
    if dry_run:
        print(f"[DRY RUN] Would execute: docker {' '.join(cmd)}")
        return True

    # Execute
    result = run_docker_command(cmd)

    if result and result.returncode == 0:
        print(f"✓ Created: {name}")
        return True
    elif result and "already exists" in result.stderr:
        print(f"⊘ Already exists: {name}")
        return True
    else:
        print(f"✗ Failed: {name}")
        if result:
            print(f"  Error: {result.stderr.strip()}", file=sys.stderr)
        return False


def bootstrap_networks(config_path, dry_run=False):
    """Bootstrap all networks from config file"""
    config_file = Path(config_path)

    if not config_file.exists():
        print(f"Error: Config file not found: {config_path}", file=sys.stderr)
        return 1

    # Parse config file
    try:
        with open(config_file, "rb") as f:
            if config_file.suffix in [".toml"]:
                config = tomllib.load(f)
            else:
                print(
                    f"Error: Unsupported file format: {config_file.suffix}",
                    file=sys.stderr,
                )
                return 1
    except Exception as e:
        print(f"Error parsing config file: {e}", file=sys.stderr)
        return 1

    # Get networks section
    networks = config.get("networks", {})
    if not networks:
        print("Error: No networks defined in config", file=sys.stderr)
        return 1

    if dry_run:
        print(f"[DRY RUN] Would bootstrap {len(networks)} network(s)...\n")
    else:
        print(f"Bootstrapping {len(networks)} network(s)...\n")

    # Create each network
    success_count = 0
    for name, net_config in networks.items():
        if create_network(name, net_config, dry_run):
            success_count += 1

    # Summary
    print(f"\n{'=' * 50}")
    print(f"Summary: {success_count}/{len(networks)} networks ready")
    print(f"{'=' * 50}\n")

    # List created networks (skip in dry-run)
    if not dry_run:
        result = run_docker_command(
            [
                "network",
                "ls",
                "--filter",
                "label=purpose",
                "--format",
                "table {{.Name}}\\t{{.Driver}}\\t{{.Scope}}\\t{{.Labels}}",
            ]
        )
        if result:
            print(result.stdout)

    return 0 if success_count == len(networks) else 1


def main():
    # Handle plugin metadata request
    if len(sys.argv) > 1 and sys.argv[1] == "docker-cli-plugin-metadata":
        print(json.dumps(PLUGIN_METADATA, indent=2))
        return 0

    # Docker passes the plugin name as the first argument after the script name
    # So we need to skip it when parsing arguments
    # Example: docker nbs --file foo.toml -> sys.argv = ['docker-nbs', 'nbs', '--file', 'foo.toml']
    args_to_parse = sys.argv[1:]

    # Skip the plugin name if it's the first argument
    if args_to_parse and not args_to_parse[0].startswith("-"):
        args_to_parse = args_to_parse[1:]

    # Parse arguments
    parser = argparse.ArgumentParser(
        description="Bootstrap Docker networks from configuration file",
        prog="docker nbs",  # or "docker net" depending on your filename
    )
    parser.add_argument(
        "-f",
        "--file",
        default="./networks.toml",
        help="Path to config file (default: ./networks.toml)",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show what would be created without actually creating",
    )

    args = parser.parse_args(args_to_parse)

    # Bootstrap networks
    return bootstrap_networks(args.file, args.dry_run)


if __name__ == "__main__":
    sys.exit(main())
